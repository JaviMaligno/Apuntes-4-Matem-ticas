setwd("C:/Users/Javi/Desktop/GitHub/Apuntes-4-Matem-ticas/ADM/Prácticas")
load("C:/Users/Javi/Desktop/GitHub/Apuntes-4-Matem-ticas/ADM/Prácticas/Práctica 6/druguse.RData")
#1. Leer el conjunto de datos
#############################
X= read.table("Percepcion.txt",header=TRUE,
row.names=1)
X
#1. Leer el conjunto de datos
#############################
X= read.table("Percepcion.txt",header=TRUE,
row.names=1)
setwd("C:/Users/Javi/Desktop/GitHub/Apuntes-4-Matem-ticas/ADM/Prácticas/Práctica 6")
#1. Leer el conjunto de datos
#############################
X= read.table("Percepcion.txt",header=TRUE,
row.names=1)
summary(X)
X
boxplot(X)
#2. Calcular y analizar la matriz de correlaciones
##################################################
(R=cor(X))    #Posibles grupos:{1,3,4} y {2,5}
#install.packages("corrplot")
library(corrplot)
corrplot(R,method="ellipse")
install.packages("corrplot")
library(corrplot)
corrplot(R,method="ellipse")
det(R)
#cor=TRUE: datos tipificados
plot(princomp(X,cor=TRUE))   #Sugiere dos factores
(autoval= eigen(R)$values)   #autovalores y autovectores
round(autoval,2)
(autovec= eigen(R)$vectors)
m= 2  #número de factores
L=autovec[,1:m]%*%diag(sqrt(autoval[1:m]))
#Cargas factoriales
rownames(L)= colnames(X)
#Coinciden con las correlaciones entre
#variables y factores (R)
colnames(L)= paste("Factor",1:m)
L
(h= apply(L^2,1,sum))   #comunalidades
(psi= diag(R)-h)        #varianzas específicas
cbind(L,h,psi)           #Parece ser necesario aplicar alguna rotación
#Contribuciones de los factores
contrib=   apply(L^2,2,sum)
contrib   #conciden con autoval[1:2]
autoval[1:m]
resumen= matrix(NA,nrow=m,ncol=3)
resumen[,1]=  contrib[1:m]
resumen[,2]= 100*resumen[,1]/sum(autoval)
resumen[,3]= cumsum(resumen[,2])
colnames(resumen)= c("Varianza","Porcentaje",
"Porcentaje acumulado")
resumen
#3.2. Representar gráficamente las cargas
#factoriales
plot(L,xlim=c(-0.2,1.4),ylim=c(-0.8,0.8),
type="n",main="Cargas factoriales",
xlab="Factor 1",ylab="Factor 2",asp=1)
#asp=1 Para que coincidan las escalas x e y
text(L,labels=rownames(L),cex=0.8)
grid()
abline(h=0,v=0,lty=2)
#4. Aplicar el método de rotación varimax
#########################################
#4.1. Obtener la matriz de rotación y su
#representación gráfica
(rotvarimax= varimax(L))
phi= asin(rotvarimax$rotmat[2,1])
phi             #Ángulo de rotación en radianes
phi*360/(2*pi)  #Ángulo de rotación en grados
T=rotvarimax$rotmat #matriz de rotación
T%*%t(T)  #Es ortogonal
arrows(0,0,T[1,1],T[2,1],lty=2,lwd=2,col="red")
arrows(0,0,T[1,2],T[2,2],lty=2,lwd=2,col="red")
#4.2. Obtener la matriz de cargas rotada
#y su interpretación.
#se aplica unclass para que ya no sea de
#la clase "loadings" que no visuliza valores
#inferiores a 0.1 (en valor absoluto)
Lrot=unclass(rotvarimax$loadings)
#(Lrot= L%*%T)  #es lo mismo
colnames(Lrot)= c("F1 rot.","F2 rot.2")
Lrot
View(rotvarimax)
View(`T`)
#4.3. Calcular las comunalidades, varianzas
#específicas y contribuciones de los factores
#(coinciden con la solución no rotada).
(hrot= apply(Lrot^2,1,sum))   #comunalidades
(psirot= diag(R)-hrot)        #varianzas específicas
cbind(L,h,psi,Lrot,hrot,psirot)
contribrot=   apply(Lrot^2,2,sum)
rbind(cbind(contrib,contribrot),
Total=c(sum(contrib),sum(contribrot)))
resumenrot= matrix(NA,nrow=m,ncol=3)
resumenrot[,1]=  contribrot[1:m]
resumenrot[,2]= 100*resumenrot[,1]/sum(autoval)
resumenrot[,3]= cumsum(resumenrot[,2])
colnames(resumenrot)= c("Varianza","Porcentaje",
"Porcentaje acumulado")
resumenrot
resumen      #resumen para la solución original
#4.4. Obtener las puntuaciones factoriales asociadas
#a través de mínimos cuadrados ordinarios y
#representarlas gráficamente.
#Puntuaciones factoriales para la rotación varimax:
#Para la solución de componentes principales
#se suele usar mínimos cuadrados ordinarios
#Como estamos trabajando con R,
#necesitamos las variables  tipificadas:
Z= scale(X,center=TRUE,scale=TRUE)
apply(Z,2,mean)
apply(Z,2,sd)
#Para aplicar la fórmula de transparencias
#las variables deben centrarse
#aquí no hace falta
Xcent=scale(Z,center=TRUE,scale=FALSE)
summary(Xcent)
Frot= t(solve(t(Lrot)%*%Lrot)%*%t(Lrot)%*%t(Xcent))
rownames(Frot)= rownames(X)
Frot
#Comprobar que tienen media 0
#y matriz de cov=I
colMeans(Frot)
cov(Frot)
#Nube de puntos de las puntuaciones factoriales
plot(Frot,type="n",
main="Puntuaciones factoriales mediante mínimos cuadrados \nRotación varimax")
text(Frot,labels=rownames(F),cex=0.7,col="red")
abline(h=0,v=0,lty=2,col="blue")
text(Frot,labels=rownames(F),cex=0.7,col="red")
rownames(Frot)= rownames(X)
Frot
#Nube de puntos de las puntuaciones factoriales
plot(Frot,type="n",
main="Puntuaciones factoriales mediante mínimos cuadrados \nRotación varimax")
text(Frot,labels=rownames(F),cex=0.7,col="red")
abline(h=0,v=0,lty=2,col="blue")
#Aproximación a R
R2=Lrot%*%t(Lrot) + diag(psirot)
R2
R
Rresid= R-R2
round(Rresid,3)
sum(Rresid^2)
sum(autoval[-c(1:m)]^2)  #(Proposición 2)
text(Frot,labels=rownames(Frot),cex=0.7,col="red")
R2
R
Rresid= R-R2
round(Rresid,3)
sum(Rresid^2)
sum(autoval[-c(1:m)]^2)  #(Proposición 2)
#5. Comprobar que el método de Factores Principales
#   falla tras la primera iteración
####################################################
#Comenzamos con una estimación inicial
#de las comunalidades
solve(R)   #1/rii no se pueden calcular
#Una alternativa:
hini=apply((R-diag(ncol(R)))^2,1,max)
R0= R
diag(R0)=hini   ; R0
(autoval0= eigen(R0)$values)
(autovec0= eigen(R0)$vectors)
plot(autoval0,type="h")     #Sugiere m=2
Lf=autovec0[,1:m]%*%diag(sqrt(autoval0[1:m]))  #Cargas factoriales
rownames(Lf)= colnames(X)  #Coinciden con las correlaciones
colnames(Lf)= paste("Factor",1:m)  #entre variables y factores (R)
Lf      #De nuevo sugiere rotación
L       #Solución C.P.
resumenf= matrix(NA,nrow=m,ncol=3)
resumenf[,1]=  autoval0[1:m]
resumenf[,2]= 100*resumenf[,1]/sum(autoval0)
resumenf[,3]= cumsum(resumenf[,2])
colnames(resumenf)= c("Varianza","Porcentaje","Porcentaje acumulado")
resumenf
apply(Lf^2,2,sum)
#en este ejemplo no podría continuar la iteración,
#de hecho al calcular nuevas estimaciones de las
#comunalidades,algunas son >1 (Caso de Heywood)
#y la correspondiente especificidad es <0
(h1= apply(Lf^2,1,sum))   #comunalidades
(psi1= diag(R)-h1)        #varianzas específicas
#1. Leer los datos y calcular las medidas
#de adecuación muestral. Aplicar el test
#de esfericidad de Bartlett
#########################################
datos= read.table("Seishu.txt",header=FALSE)
colnames(datos)= c("Sabor","Olor","Ph",
"Acidez1","Acidez2","Sake",
"Azúcar_reducido","Azúcar_Total",
"Alcohol", "Formyl-Nitrog.")
datos
summary(datos)
#Medidas de adecuación muestral
install.packages("rela")
library(rela)
PAF=paf(as.matrix(datos))
#KMO mide la proporción de varianza que es común,
#atribuible a factores subyacentes
PAF$KMO #Aquí un 55% (Bajo)
PAF$MSA  #Medidas de adecuación muestral
#el test de esfericidad de Bartlett contrasta
#la hipótesis nula de que la matriz
#var-cov es proporcional a la identidad,
#en este caso, R=I, implicaría la
#incorrelación entre las variables
PAF$Bartlett #estadístico del test
#cálculo del p-valor
p=ncol(datos)
gl= p*(p-1)/2
1-pchisq(PAF$Bartlett,gl)   #Contraste significativo
#2. AF mediante el método de
#   Componentes Principales (R)
############################
R=cor(datos)
(autoval= eigen(R)$values)
(autovec= eigen(R)$vectors)
plot(princomp(R))  #Parece sugerir 4
100*sum(autoval[1:4])/10   #84.4%
m= 4  #número de factores
L=autovec[,1:m]%*%diag(sqrt(autoval[1:m]))  #Cargas factoriales
rownames(L)= colnames(datos)     #Coinciden con las correlaciones
colnames(L)= paste("Factor",1:m)  #entre variables y factores (R)
round(L,3)
(h= apply(L^2,1,sum))   #comunalidades
(psi= diag(R)-h)        #varianzas específicas
cbind(L,h,psi)
#Contribuciones de los factores
contrib=   apply(L^2,2,sum)
contrib   #conciden con autoval[1:m]
resumen= matrix(NA,nrow=m,ncol=3)
resumen= matrix(NA,nrow=m,ncol=3)
resumen[,1]=  contrib[1:m]
resumen[,2]= 100*resumen[,1]/sum(autoval)
resumen[,3]= cumsum(resumen[,2])
colnames(resumen)= c("Varianza","Porcentaje",
"Porcentaje acumulado")
resumen
#El siguiente gráfico representa las variables
#según las cargas factoriales
plot(L,type="n",main="Cargas factoriales",
xlab="Factor 1",ylab="Factor 2")
text(L,labels=rownames(L),cex=0.8)
grid()
abline(h=0,v=0,lty=2)
#Rotación varimax, simplifica la interpretación
(rotvarimax= varimax(L))
(Lrot= varimax(L)$loadings)
plot(Lrot[,1:2],type="n",
main="Cargas factoriales, rotación varimax",
xlab="Factor 1",ylab="Factor 2")
text(Lrot[,1:2],labels=rownames(L),cex=0.8)
grid()
abline(h=0,v=0,lty=2)
(hrot= apply(Lrot^2,1,sum))  #comunalidades
(psirot= diag(R)-hrot)        #varianzas específicas
cbind(L,h,psi,Lrot,hrot,psirot)
#Puntuaciones factoriales para la rotación varimax
#Para la solución de componentes principales
#se puede usar mínimos cuadrados ordinarios
#Los datos deben ser centrados,
#o sea, scale(...center=TRUE)
#Como estamos trabajando con la matriz de
#correlaciones, en realidad las variables
#han de ser tipificadas, por
#tanto también scale=TRUE
Xcent=scale(datos,center=TRUE,scale=TRUE)
Frot=t(solve(t(Lrot)%*%Lrot)%*%t(Lrot)%*%t(Xcent))
rownames(Frot)= 1:nrow(datos)
Frot
#Nube de puntos de las puntuaciones factoriales
plot(Frot,type="n",main="Puntuaciones factoriales
mediante mínimos cuadrados \n Rotación varimax")
text(Frot,labels=rownames(Frot),cex=0.7,col="red")
abline(h=0,v=0,lty=2,col="blue")
plot(Frot[,c(1,3)],type="n",
main="Puntuaciones factoriales mediante mínimos cuadrados \nRotación varimax")
text(Frot[,c(1,3)],labels=rownames(Frot),cex=0.7,col="red")
abline(h=0,v=0,lty=2,col="blue")
#Aproximación a R
R4=Lrot%*%t(Lrot) + diag(psirot)
R4
R
Rresid= R-R4
sum(Rresid^2)
sum(autoval[-c(1:m)]^2)
#3. Método de Factores  Principales
#####################################
#install.packages(c("psych","GPArotation"))
library(psych)    #Necesita la librería GPArotation
library(GPArotation)
af.fp = fa(datos,4,fm="pa",rotate="varimax",max.iter=350)
#3. Método de Factores  Principales
#####################################
install.packages(c("psych","GPArotation"))
library(psych)    #Necesita la librería GPArotation
af.fp = fa(datos,4,fm="pa",rotate="varimax",max.iter=350)
#####################################
#4. Estimar el modelo AF mediante el método
#   de máxima verosimilitud (variables tipificadas)
#   (función factanal)
###################################################
af.mv = factanal(datos,m,scores="Bartlett")
#scores="regresssion" para el otro método
af.mv #Ya aplica rotación varimax; contraste satisfactorio
cbind(Comunalidad=1-af.mv$uniqueness,Especificidad=af.mv$uniqueness)
L=loadings(af.mv); L
for (i in 1:(m-1))
for (j in (i+1):m)
{ plot(L[,c(i,j)],type="n",
main="Cargas factoriales; Máxima Verosimilitud\nRotación varimax")
text(L[,c(i,j)],labels=rownames(L),cex=0.7,col="red")
abline(h=0,v=0,lty=2,col="blue")
}
#Puntuaciones factoriales;
F= af.mv$scores
rownames(F)= 1:nrow(datos)
for (i in 1:(m-1))
for (j in (i+1):m)
{ plot(F[,c(i,j)],type="n",
main="Puntuaciones factoriales Barlett \nRotación varimax")
text(F[,c(i,j)],labels=rownames(F),cex=0.7,col="red")
abline(h=0,v=0,lty=2,col="blue")
}
load(file="druguse.RData")  #Matriz de correlaciones
druguse
#library(corrplot)
corrplot(druguse,method="ellipse")
#2. Estimar el modelo AF mediante máxima verosimilitud
#   seleccionando el número de factores a partir
#   del procedimiento de bondad de ajuste
######################################################
#Determinar el número de factores según p-valores
pvalores<-sapply(1:7, function(nf)
factanal(covmat = druguse, factors = nf,
method = "mle", n.obs = 1634)$PVAL)
names(pvalores)<- 1:7
round(pvalores,4)  #Sugiere 6 factores
plot(eigen(druguse)$values,type="h")
#AF máxima verosimilitud con 6 factores
af.mv<-factanal(covmat = druguse, factors = 6,
method = "mle", n.obs = 1634)
af.mv       #Rotación varimax (por defecto)
#diferencias entre correlaciones observadas y reproducidas
pfun <- function(nf) {
fa <- factanal(covmat = druguse, factors = nf,
method = "mle", n.obs = 1634)
est <- tcrossprod(fa$loadings) + diag(fa$uniquenesses)
ret <- round(druguse - est, 3)
colnames(ret) <- rownames(ret) <-
abbreviate(rownames(ret), 3)
ret
}
pfun(6)
summary(pfun(6))   #con 6 hay un buen ajuste
summary(pfun(3))
boxplot(pfun(6),ylim=c(-0.1,0.1),col="red",
main="Correlaciones Residuales\n Método de máxima verosimilitud" )
boxplot(pfun(3),add=TRUE,col="lightblue")
legend("topleft",col=c("red","lightblue"),pch=4,
legend=c("6 Factores","3 Factores"))
#3. Método de Factores Principales
##################################
library(psych)
library(GPArotation)
af.fp <- fa(druguse,6,n.obs=1634,fm="pa",rotate="none")
af.fp             #Poco interpretable
plot(af.fp)
fa.diagram(af.fp)
#rotación varimax
af.fp <- fa(druguse,6,n.obs=1634,fm="pa",rotate="varimax")
af.fp             #Mejor
plot(af.fp)
fa.diagram(af.fp)
#Rotación oblicua:
af.fp <- fa(druguse,6,n.obs=1634,fm="pa")
af.fp
plot(af.fp)
af.fp
af.fp
#Rotación oblicua:
af.fp <- fa(druguse,6,n.obs=1634,fm="pa")
fa.diagram(af.fp)
fa.diagram(af.fp)
