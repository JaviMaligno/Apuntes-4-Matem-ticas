\documentclass[a4paper,12pt]{article}
\usepackage{makeidx}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amscd,amsthm}
\usepackage{amssymb}
\usepackage{tabularx}
\usepackage{amssymb,eucal,bezier,graphicx}
\usepackage{times,amssymb}
\usepackage[ansinew]{inputenc}
\usepackage{multicol}
\usepackage{hyperref}
\usepackage{multicol}
\usepackage{verbatim}
\usepackage{tikz-cd}
\usetikzlibrary{graphs}
\usetikzlibrary{arrows.meta}
\usepackage{listings}


\newtheorem{thm}{Theorem}[section]
\newtheorem{coro}[thm]{Corolario}
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{prob}[thm]{Problema}
\newtheorem{defi}[thm]{Definición}
\newtheorem{conj}[thm]{Conjectura}
\newtheorem{nota}[thm]{Note}
\newtheorem{ejem}[thm]{Ejemplo}
\providecommand{\gilb}[1]{\mathcal{G}_{#1}}
\providecommand{\abs}[1]{\left|{#1}\right|}
\newcommand{\Pri}{\mathbb{P}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newtheorem{demo}[thm]{Proof}
\providecommand{\gabs}[1]{\left|{#1}\right|}
\begin{document}

%%Los tres siguientes comandos estaban inicialmente desinsertados, pero no funcionaban en concordancia en el texto

\renewcommand{\figurename}{Figure}

\renewcommand\thefigure{\arabic{section}.\arabic{figure}} 

\numberwithin{figure}{section} 

\renewcommand\refname{Bibliografia}


\begin{center} {\large \bf Estudio de la Conjetura de Gilbreath}
\end{center}

\begin{center}
{\bf Eleazar Duarte Aponte, Rafael González López,\\
Rocío Palacios Cantillo, Luis Palma Blanco,\\
Diego Pedraza López, María de los Remedio Boza Ruíz}
\end{center}

\begin{center}
\small{ Teoría Analítica de Números \\
\small Universidad de Sevilla. }
\end{center}

\vspace{0.4cm}

\begin{center}
{\bf Abstract}

\end{center}

\begin{quotation}
\noindent En este trabajo vamos a TAL TAL TAL
\end{quotation}

\vspace{0.1cm}



\section*{Introducción}
Durante el año 1958, Norman Gilbreath buscaba, como muchos otros matemáticos a lo largo de la historia, una forma de generar los primos. Para ello comenzó a estudiar las diferencias entre primos consecutivos. Si volvemos a repetir las diferencias en valor absoluto una y otra vez sobre la sucesión que nos queda, obtenemos algo de esta forma
$$
\begin{array}{c c c c c}
2 & 3 & 5 & 7 & 11\\
\hline
1 & 2 & 2 & 4 &\\
1 & 0 &  2 &  &\\
1 & 2 & & & \\
1 &   &  & & 
\end{array}
$$
Si denotamos $d^k_n$ al $n$-ésimo elemento de la $k$-ésima fila, entonces tenemos que
\begin{gather*}
d^1_n = p_{n+1}-p_n\\
d^k_n = \abs{d_{n+1}^{k-1}-d_{n}^{k-1}}
\end{gather*}
\section{Preliminares}


\section{Estudio computacional de la conjetura de Gilbreath}
Utilizando una idea semejante a la que proporciona Odlyzko en \cite{odly}, programamos en C++ un algoritmo que nos permita comprobar experimentalmente la conjetura. El algoritmo es realmente eficiente, pues en un simple ordenador portatil permite comprobar la conjetura hasta $10^9$

\lstset{language=C++,
                basicstyle=\ttfamily,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{green}\ttfamily,
                morecomment=[l][\color{magenta}]{\#}
}
\begin{lstlisting}
#include <primesieve.hpp>
#include <iostream>
#include <vector>

// Comprueba la conjetura de Gilbreath hasta 10^9
// usando ideas de Odlyzko
int main () {
	// Diagonal 645:
	std::vector<uint64_t> nums 
	{4703,12,0,6,4,2,0,2,0,0,2,2,0,4,2,0,0,2,2,
	2,0,0,0,2,0,0,0,2,0,2,2,2,2,2,0,0,0,2,0,0,
	0,2,0,2,2,2,2,0,0,2,2,0,0,0,0,0,0,2,2,2,2,
	2,0,0,2,2,0,0,2,0,0,2,2,2,0,0,2,0,0,0,2,2,
	2,2,0,0,2,0,2,0,0,0,0,2,0,0,2,0,0,0,2,2,2,
	2,0,2,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2,0,0,2,
	2,2,2,0,0,2,2,2,2,2,2,2,0,0,0,2,2,0,2,0,2,
	2,2,0,2,0,2,0,0,2,0,0,0,2,0,0,2,2,2,2,2,0,
	0,0,0,2,2,0,0,2,0,2,0,2,2,2,2,0,2,0,2,0,0,
	0,2,0,2,2,0,0,0,0,2,2,2,0,2,0,2,2,2,2,0,0,
	2,0,2,0,0,2,0,0,0,0,0,0,2,0,2,2,2,2,2,2,2,
	2,0,2,2,0,0,0,2,2,0,0,2,0,0,2,0,2,0,0,0,0,
	2,0,2,2,0,0,2,0,2,2,0,0,2,2,2,0,2,0,2,2,0,
	2,2,0,2,2,2,2,2,2,0,0,2,2,2,0,0,0,2,0,2,0,
	0,2,2,2,2,0,0,2,2,2,0,0,2,2,0,0,0,2,2,2,0,
	0,0,2,0,2,2,2,0,2,0,0,2,0,0,2,0,0,2,0,0,0,
	2,0,0,2,0,2,0,0,2,0,0,0,2,0,0,0,2,2,2,2,0,
	0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,2,0,2,2,2,2,
	2,0,2,0,0,2,0,0,0,0,2,0,0,2,0,0,0,2,2,2,2,
	2,2,0,2,0,0,0,0,0,2,2,0,2,2,0,2,2,0,2,0,0,
	2,0,0,0,2,2,2,2,0,2,0,0,0,2,2,2,2,2,2,0,2,
	2,2,2,2,2,0,2,2,0,2,2,0,0,0,2,2,0,0,2,0,2,
	2,0,0,0,0,2,2,0,0,0,2,0,0,2,2,0,0,2,0,2,2,
	0,2,0,0,0,0,0,2,0,2,0,0,0,2,0,2,0,2,0,2,0,
	2,2,2,0,0,2,0,0,0,0,2,0,0,0,0,0,2,0,2,0,0,
	0,0,0,2,2,2,0,2,0,0,2,2,0,2,0,0,0,0,0,0,0,
	0,2,2,2,2,2,2,2,2,0,0,0,2,2,2,0,2,2,0,0,0,
	2,0,2,2,0,2,2,0,2,2,0,2,0,0,2,2,2,2,0,0,0,
	0,2,0,0,0,2,2,0,2,0,0,0,2,0,2,2,2,2,0,2,2,
	0,2,0,0,0,0,0,0,0,2,2,2,2,0,0,0,2,2,0,2,2,
	0,2,2,0,0,0,1};

uint64_t nexto;
primesieve::iterator it;
it.skipto(4704);
uint64_t tempo;
for (long p = 0; p < 2*pow(10,8); ++p) {
	nexto = it.next_prime();
	
	for (int i = 0; i < 635; ++i) {
		tempo = abs(nexto-nums[i]);
		nums[i] = nexto;
		nexto = tempo;
	}
	
	// Con un poco de loop unrolling 
	//es más eficiente
	for (int i = 0; i < 634; ++i) {
		tempo = abs(nexto-nums[i]);
		nums[i] = nexto;
		nexto = tempo;
		tempo = abs(nexto-nums[++i]);
		nums[i] = nexto;
		nexto = tempo;
		tempo = abs(nexto-nums[++i]);
		nums[i] = nexto;
		nexto = tempo;
		tempo = abs(nexto-nums[++i]);
		nums[i] = nexto;
		nexto = tempo;
		tempo = abs(nexto-nums[++i]);
		nums[i] = nexto;
		nexto = tempo;	}
		
	if (nums[634] != 0 && nums[634] != 2) {
		std::cout << "Contraejemplo en Paso"
		<< p << ":" << nums[634] << std::endl;
		return 0;
	}
}
std::cout<<"CIERTO"<<std::endl;
}
\end{lstlisting}

Para tener una representación gráfica del triángulo que se forma al calcular los sucesivos $d_n$, hemos implementado el siguiente código en Haskell 

\lstset{
  frame=none,
  xleftmargin=2pt,
  stepnumber=1,
  numbers=left,
  numbersep=4pt,
  numberstyle=\ttfamily\tiny\color[gray]{0.2},
  belowcaptionskip=\bigskipamount,
  captionpos=b,
  escapeinside={*'}{'*},
  language=haskell,
  tabsize=1,
  emphstyle={\bf},
  commentstyle=\it,
  stringstyle=\mdseries\rmfamily,
  showspaces=false,
  keywordstyle=\bfseries\rmfamily,
  columns=flexible,
  basicstyle=\small\sffamily,
  showstringspaces=false,
  morecomment=[l]\%,
}
\small{
\begin{lstlisting}
import Data.Numbers.Primes
import Data.List

-- Introducimos una lista de n números que nos sirve como sucesión numérica.
-- En este caso, vamos a tomar la lista de los 10^24 primeros primos
suc :: [Int]
suc = take (10^24) primes

-- Construimos la función que nos dé la lista en la siguiente etapa
fun :: [Int] -> [Int]
fun xs = zipWith (\x y -> abs (x-y)) xs (tail xs)

-- Lista infinita de listas infinitas de la pirámide de Gilbreath
gilbreath_seq :: [[Int]]
gilbreath_seq = iterate fun primes

-- Comprueba la conjetura de Gilbreath para hasta n primos
conjetura :: Int -> Bool
conjetura n = all (==1) . take n . tail . map head $ gilbreath_seq

triangulo :: Int -> [[Int]]
triangulo n = [take (n-i) xs | (i,xs) <- zip [0..] (take n gilbreath_seq)]

dibujaTriangulo :: Int -> IO ()
dibujaTriangulo n = mapM_ putStrLn $ map (unwords . map show) a
	where a = take n (triangulo n)
\end{lstlisting}}
Mostramos una salida del código para hacernos una idea de cómo funciona el código

\begin{lstlisting}
*Main> dibujaTriangulo 12
2 3 5 7 11 13 17 19 23 29 31 37
1 2 2 4 2 4 2 4 6 2 6
1 0 2 2 2 2 2 2 4 4
1 2 0 0 0 0 0 2 0
1 2 0 0 0 0 2 2
1 2 0 0 0 2 0
1 2 0 0 2 2
1 2 0 2 0
1 2 2 2
1 0 0
1 0
1
\end{lstlisting}

\section{Árbol de Gilbreath}

Consideremos todas las sucesiones $\{a_n\}_{n\in I}$ tales que $a_1=2$, $a_2=3$, $a_n$ es impar y mayor que $3$ para todo $n$. Si no hay confusión sobre la sucesión de la que estamos hablando, notaremos 
\begin{gather*}
d^1_n = a_{n+1}-a_n\\
d^k_n = \abs{d_{n+1}^{k-1}-d_{n}^{k-1}}
\end{gather*}
Normalmente $I=\N$ o $I=\N_k$.
\begin{defi}
En las condiciones anteriores, diremos que $\{a_n\}_{n\in I}$ es una sucesión de Gilbreath si $d^k_1 =1$ para todo $k\in I$.
\end{defi}
Una consecuencia trivial de esta definición es que
\begin{prop}
La conjetura de Gilbreath es equivalente a que $\{p_n\}$ sea una sucesión de Gilbreath. 
\end{prop}
\subsection{Crecimiento y distribución}
Aunque estamos particularmente interesados en estudiar las sucesiones de Gilbreath crecientes, sin embargo hemos damos una definición más relajada con el fin de agilizar su estudio mediante una serie de nuevos conceptos.
\begin{defi}
Sea $S=\{a_n\}_{n\in\N_k}$ una sucesión finita de Gilbreath. Definimos $\mathcal{G}_S$ como el conjunto de todos los elementos tales que si $m\in \mathcal{G}_S$ entonces la sucesión definida como $b_n = a_n$ si $n\leq k$ y $b_{k+1}=m$ sigue siendo una sucesión de Gilbreath.
\end{defi}
\begin{defi}
En las condiciones de la definición anterior denotamos $\mathcal{G}^+_S$ al conjunto $\{s \in \mathcal{G}_S \mid s > a_n\}$. 
\end{defi}
Este último concepto tendrá particular interés cuando $S$ sea además creciente. 
\begin{ejem}Vamos a ilustrar estos conceptos con algunos ejemplos. 
\begin{enumerate}
\item Si $S=\{2,3\}$ entonces $\gilb{S}=\{3,5\}$. 
\item Si $S=\{2,3,5,7\}$ entonces $\gilb{S}=\{3,5,7,9,11\}$. 
\item Si $S=\{2,3,5,9\}$ entonces $\gilb{S}=\{3,5,7,9,11,13,15,17\}$.
\item Si $S=\{2,3,5,7,11\}$ entonces $\gilb{S}^+ = \{13,15,17,19,21\}$.
\end{enumerate}
\end{ejem}
\begin{defi}
Generalizando el concepto, diremos que $\{a_n\}_{i\in I}$ es mayor que $\{b_n\}_{i\in I}$ si $a_i \geq b_i$ para todo $i\in I$.
\end{defi}
\begin{conj} Sean $S$ y $K$ dos sucesiones finitas de Gilbreath. Si $S\geq K$, entonces $\mathcal{G}_K\subset \mathcal{G}_S$.
\end{conj}

\begin{conj}
Sea la sucesión $\{m_n\}_{n\in \N}$ la menor sucesión creciente de Gilbreath y $\{M_n\}_{n\in \N}$ la mayor sucesión creciente de Gilbreath. Ambas definiciones en el sentido de que, sea $\{a_n\}_{n\in \N}$ otra sucesión creciente de Gilbreath, entonces $m_n \leq a_n \leq M_n$ para todo $n \in \N$. Entonces
\begin{itemize}
\item $\{m_n\}_{n\in \N}$ es la sucesión $m_1 = 2$, $m_n = 2n-1$ si $n>1$.
\item $\{M_n\}_{n\in \N}$ es la sucesión $M_1=2$, $M_n = 2^{n-1}+1$ si $n>1$.
\end{itemize}
\end{conj}

Vamos a estudiar $\gilb{S}$.
\begin{conj}
Sea $S$ una sucesión finita de Gilbreath. Entonces $\exists n \in \N$ tal que 
$$\gilb{S} = \{2k+1\mid k\in \N_n\}$$
\end{conj}
\begin{coro}
Sea $S$, la sucesión finita formada por los $i$ primeros términos de la sucesión $\{M_n\}_{n\in\N}$. Entonces,
$$
\gilb{S}=\{2k+1\mid 1\leq k \leq 2^{i-1}\}
$$
\end{coro}
\begin{defi}
Sea $S_k=\{p_n\}_{n\in \N_k}$ la sucesión finita de los primeros $k$ primos. Definimos la sucesión $\{Q_n\}_{n\in\N}$ como $Q_1=2$, $Q_2=3$, y $Q_k=\max \gilb{S_k}$. 

Los primero valores de la sucesión son 
\begin{align*} \{Q_n\}=\{&9,11,21,21,27,27,33,41,51,55,57,53,63,67,89,85,95,105,121,\\&129,137,129,135,137,155,217,189,\dotsc\}
\end{align*}
\end{defi}
\begin{coro}
La conjetura del Gilbreath es cierta si y solo si $Q_n \geq p_n$ para todo $n\in \N$.
\end{coro}
¿Qué sabemos sobre $Q_n$? En principio no mucho. Si analizamos la sucesión $\{Q_n-p_n\}$ obtenemos estos primeros 30 valores:
\begin{align*} \{Q_n-p_n\}=\{&7,8,16,14,16,14,16,22,28,26,26,16,22,24,42,32,36,44,30,\\
&38,32,42,46,48,32,34,34,48,108,76,\dotsc\}
\end{align*}
Es decir, en principio, parece que el \textit{gap} no solo se mantiene constantemente positivo sino que aumenta. 
\subsection{Estudio probabilístico}



\newpage






\begin{thebibliography}{99}

\bibitem{odly}  Odlyzko, A. (1993). Iterated Absolute Values of Differences of Consecutive Primes. Mathematics of Computation, 61(203), 373-380. doi:10.2307/2152962

\bibitem{rguy}  Kenneth Guy, R. (1993). Iterated Absolute Values of Differences of Consecutive Primes. Mathematics of Computation, 61(203), 373-380. doi:10.2307/2152962

\end{thebibliography}

\end{document}
